# MyKeyboardTyping - キーボード管理機能仕様書

## 1. 概要

このドキュメントではWebHID APIを利用したキーボード検出、キーマップ取得、レイヤー管理などのキーボード関連機能の詳細を定義します。

---

## 2. WebHID API統合

### 2.1 キーボード検出

#### 機能説明
- システムに接続されているRemap対応キーボードを自動検出
- デバイス情報（VID/PID、製品名）からキーボード種別を特定
- ユーザーが目的のキーボードを選択可能なリストを提供

#### 実装詳細

**キーボード検出処理:**
```
1. WebHID API の `navigator.hid.requestDevice()` を呼び出し
2. ユーザーがOS側のダイアログでキーボードを選択
3. デバイスのVID/PIDを確認
4. Remap対応キーボード一覧と照合
5. 未対応の場合は警告メッセージを表示
6. 検出されたキーボード情報を画面に一覧表示
```

**VID/PID確認方法:**
- Ergo68 の標準 VID/PID を定義（例：`0x04D8:0xEB3D`）
- 将来的に他キーボード対応時は、VID/PID テーブルを拡張

**エラーケース:**
| シナリオ | 対応 |
|--------|------|
| WebHID未対応ブラウザ | ブラウザ非対応メッセージ + リンク提示 |
| ユーザーがダイアログをキャンセル | 選択画面に戻る |
| Remap非対応キーボード接続時 | 警告メッセージ表示 + 使用可否選択肢 |

### 2.2 キーボードへのアクセス

#### 接続管理
```typescript
// キーボードオブジェクト構造
interface KeyboardDevice {
  vendorId: number;        // USB Vendor ID
  productId: number;       // USB Product ID
  productName: string;     // 例: "Ergo68"
  deviceHandle: HIDDevice; // WebHID デバイスハンドル
  isConnected: boolean;    // 接続状態
}
```

#### キーボード初期化フロー
```
1. キーボード選択
2. `device.open()` でHIDデバイスを開く
3. キーマップを取得（レイヤー0～3）
4. 初期化完了 → タイピング練習画面へ遷移
5. ページ離脱時に `device.close()` でクリーンアップ
```

---

## 3. キーマップ取得

### 3.1 キーマップのデータ構造

#### キーマップフォーマット
Remapから取得できるキーマップデータの形式：

```typescript
interface KeymapData {
  layers: Layer[];           // レイヤー0～3
  encoders?: EncoderData[];  // ロータリーエンコーダ（必要に応じて）
}

interface Layer {
  layerNumber: number;       // 0～3
  keymap: KeyCode[][];       // [row][col] = キーコード
}

interface KeyCode {
  code: string;              // HID キーコード（"0x04", "0x1E" など）
  label: string;             // 表示用ラベル（"A", "B", "Shift" など）
  isModifier: boolean;       // 修飾キーフラグ
}
```

### 3.2 キーマップ取得方法

#### Remapからの取得
1. **Web標準API（推奨）**: Remap が公開しているAPIエンドポイント
   - キーボードID/VID/PIDを指定
   - JSONフォーマットでキーマップを取得

2. **フォールバック方式**: WebHIDで直接キーボード内部メモリから読み取り
   - QMK/VIA互換のコマンドを発行
   - キーコード配列を解析

```typescript
// キーマップ取得処理の概略
async function fetchKeymap(keyboardInfo: KeyboardInfo): Promise<KeymapData> {
  try {
    // 方式1: Remap API
    const response = await fetch(`https://api.remap-keys.app/v1/keyboards/${keyboardInfo.id}`);
    return await response.json();
  } catch (error) {
    // 方式2: WebHID直接読み取り
    return await readKeymapViaWebHID(device);
  }
}
```

### 3.3 キーコード変換表

HIDキーコードと表示ラベルの対応：

| HIDコード | ラベル | 特記事項 |
|----------|--------|--------|
| 0x04 | A | |
| 0x05 | B | |
| ... | ... | |
| 0x39 | CapsLock | 修飾キー |
| 0x02 | 1 | Shift+1で!に |
| ... | ... | |

**詳細は `05_データ構造定義.md` の「HIDキーコードマッピング」を参照**

---

## 4. レイヤー管理

### 4.1 レイヤー構造

Ergo68は4レイヤー（0～3）をサポート：
- **レイヤー0**: デフォルトレイヤー（通常のキー配置）
- **レイヤー1**: MO(1) キー押下で有効化（将来実装）
- **レイヤー2**: MO(2) キーで有効化（将来実装）
- **レイヤー3**: MO(3) キーで有効化（将来実装）

**現在の実装**: すべてのレイヤーが同時に表示され、ユーザーが手動で表示/非表示を切り替えられる仕様。

### 4.2 レイヤー表示管理ロジック

#### 現在の実装

ユーザーが手動でレイヤーの表示/非表示を制御します。

```typescript
interface LayerState {
  visibleLayers: Set<number>;      // 表示中のレイヤー
  currentLayer: number;             // アクティブなレイヤー（将来使用）
}
```

#### レイヤー表示切り替えフロー

```
1. ユーザーがレイヤーパネルのヘッダーをクリック
2. `useLayerManager.toggleLayer(n)` を呼び出し
3. 該当レイヤーの表示状態が切り替わる
4. 複数レイヤーを同時に表示可能
5. キー入力はすべてのレイヤーで同時にハイライト
```

#### 将来実装: MO(n)キーによる自動切り替え

MO(n)キーの押下を検知して自動的にレイヤーを切り替える機能は、物理キー入力からの検知が困難なため、将来検討とします。

```typescript
// 将来実装例
const LAYER_MODIFIER_KEYS: Record<string, number> = {
  'MO(0)': 0,  // デフォルト
  'MO(1)': 1,
  'MO(2)': 2,
  'MO(3)': 3,
}

// 将来実装例: MO(n)キー検知
function handleKeyDown(event: KeyboardEvent) {
  const keyCode = getHIDKeyCode(event);
  
  // MO(n)キー（または修飾キー）かチェック
  if (isFnKey(keyCode)) {
    layerState.modifierKeys.add(keyCode);
    updateActiveLayer();
    redrawKeyboard(); // キーボード表示を更新
  }
}
```

### 4.3 複合修飾キーの扱い（将来実装）

複数の修飾キーが同時に押された場合の処理。

例：MO(n) + Shift を同時押し

**注**: 現バージョンでは未実装。

---

## 5. キーマップキャッシュ戦略

### 5.1 キャッシング
```typescript
// メモリ内キャッシュ
const keymapCache: Map<string, KeymapData> = new Map();

// キーボード選択時
async function selectKeyboard(device: HIDDevice) {
  const cacheKey = `${device.vendorId}:${device.productId}`;
  
  if (keymapCache.has(cacheKey)) {
    // キャッシュからロード
    currentKeymap = keymapCache.get(cacheKey)!;
  } else {
    // Remapから取得してキャッシュに保存
    currentKeymap = await fetchKeymap(device);
    keymapCache.set(cacheKey, currentKeymap);
  }
}
```

### 5.2 キャッシュ無効化タイミング
- ページリロード時（セッションスコープで十分）
- 将来的にはIndexedDBに永続化することも検討

---

## 6. エラーハンドリング詳細

### 6.1 WebHID APIレベル
```typescript
async function initializeKeyboard() {
  try {
    const devices = await navigator.hid.getDevices();
    
    if (devices.length === 0) {
      showErrorMessage("No keyboard detected. Please connect a Remap-compatible keyboard.");
      return;
    }
    
    // 以下の処理...
    
  } catch (error) {
    if (error.name === 'NotSupportedError') {
      showErrorMessage('Your browser does not support WebHID API.');
    } else if (error.name === 'NotAllowedError') {
      showErrorMessage('Permission denied. Please allow access to the keyboard.');
    } else {
      showErrorMessage(`Unexpected error: ${error.message}`);
    }
  }
}
```

### 6.2 キーマップ取得エラー
| エラー | 原因 | 対応 |
|-------|------|------|
| ネットワークエラー | Remapサーバーに接続不可 | リトライボタン表示 |
| 404 Not Found | キーボードがRemap未対応 | 警告メッセージ + 代替案提示 |
| タイムアウト | レスポンス遅延 | リトライ + タイムアウト設定 |

---

## 7. 将来拡張性

### 7.1 複数キーボード対応
```typescript
interface KeyboardRegistry {
  [vendorId: number]: {
    [productId: number]: KeyboardInfo
  }
}

const supportedKeyboards: KeyboardRegistry = {
  0x04D8: {
    0xEB3D: { name: 'Ergo68', layers: 4 },
    // 他のキーボードを追加
  }
};
```

### 7.2 キーボード定義ファイル
- JSONベースのキーボード定義
- 動的な読み込みが可能
- VID/PID、レイアウト情報を管理

---

## 8. テスト戦略

### 8.1 ユニットテスト
- キーマップ取得ロジック
- レイヤー表示管理ロジック
- キーコード変換処理

### 8.2 統合テスト
- キーボード検出～キーマップ取得の全フロー
- レイヤー表示切り替え機能
- キーボード接続解除時の処理

### 8.3 実機テスト
- 実際のErgo68との接続テスト
- 全レイヤーの表示確認
- 様々なキー入力のハイライト検証

### 8.4 将来テスト項目
- MO(n)キーによる自動レイヤー切り替え（未実装）
- 複数修飾キー同時押し（未実装）
