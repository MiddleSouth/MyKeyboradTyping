# MyKeyboardTyping - 入力処理と判定ロジック仕様書

## 1. 概要

このドキュメントではキーボード入力の検出、キーコード変換、タイピング判定、誤入力検出などの入力処理全般について定義します。

---

## 2. キー入力イベント処理

### 2.1 入力ソース

#### WebHID APIからの入力
```typescript
// WebHIDデバイスからのHIDレポート受信
keyboard.addEventListener('inputreport', (event) => {
  const reportData = event.data;  // Uint8Array
  const keyCodes = parseHIDReport(reportData);
  
  keyCodes.forEach(keyCode => {
    handleKeyInput(keyCode);
  });
});
```

#### キーボードのHIDレポートフォーマット
```
標準USB HID キーボードレイアウト：
- バイト0: 修飾キーフラグ（Ctrl, Shift, Alt など）
- バイト1: リザーブド
- バイト2～7: 最大6つの同時押しキーコード（8進数）

例）A キー = 0x04, B キー = 0x05, Shift = 0x02
```

### 2.2 キー入力の解析

```typescript
interface HIDReport {
  modifierByte: number;    // ビットフラグ
  keyCodes: number[];      // 複数同時押しに対応
  timestamp: number;       // 入力時刻
}

function parseHIDReport(reportData: Uint8Array): HIDReport {
  return {
    modifierByte: reportData[0],
    keyCodes: reportData.slice(2, 8).filter(code => code !== 0),
    timestamp: Date.now(),
  };
}

function isKeyPressed(modifierByte: number, modifier: string): boolean {
  const modifierMap = {
    'Shift': 0x02,
    'Ctrl': 0x01,
    'Alt': 0x04,
    'Win': 0x08,
  };
  return (modifierByte & modifierMap[modifier]) !== 0;
}
```

---

## 3. キーコード変換

### 3.1 HIDキーコード → キャラクター変換

```typescript
interface KeyCodeInfo {
  hidCode: number;           // HIDキーコード
  baseChar: string;          // 修飾なし時の文字
  shiftChar: string;         // Shift押下時の文字
  label: string;             // UI表示用ラベル
  isModifier: boolean;       // 修飾キーか
}

// キーコード定義テーブル
const keyCodeTable: Map<number, KeyCodeInfo> = new Map([
  [0x04, { hidCode: 0x04, baseChar: 'a', shiftChar: 'A', label: 'A', isModifier: false }],
  [0x05, { hidCode: 0x05, baseChar: 'b', shiftChar: 'B', label: 'B', isModifier: false }],
  // ... 他のキー
  [0x02, { hidCode: 0x02, baseChar: '', shiftChar: '', label: 'Shift', isModifier: true }],
  // ... 修飾キー
]);

function convertKeyCode(hidCode: number, modifiers: Modifiers): string {
  const keyInfo = keyCodeTable.get(hidCode);
  if (!keyInfo) return '';
  
  // 修飾キーの場合は空文字
  if (keyInfo.isModifier) return '';
  
  // Shift が押下されている場合
  if (modifiers.shift && keyInfo.shiftChar) {
    return keyInfo.shiftChar;
  }
  
  return keyInfo.baseChar;
}
```

### 3.2 日本語入力対応

#### ひらがな入力方式
```typescript
// ローマ字 → ひらがな 変換テーブル
const romajiMap: Map<string, string> = new Map([
  // 単音
  ['a', 'あ'],
  ['i', 'い'],
  ['u', 'う'],
  ['e', 'え'],
  ['o', 'お'],
  
  // 子音+母音
  ['ka', 'か'],
  ['ki', 'き'],
  ['ku', 'く'],
  ['ke', 'け'],
  ['ko', 'こ'],
  
  // 複数パターン対応（「し」→ 'si' or 'shi'）
  ['si', 'し'],
  ['shi', 'し'],
  ['ti', 'ち'],
  ['chi', 'ち'],
  ['tu', 'つ'],
  ['tsu', 'つ'],
  
  // 小書き仮名対応
  ['kya', 'きゃ'],
  ['kyu', 'きゅ'],
  ['kyo', 'きょ'],
  
  // その他
  ['nn', 'ん'],
  ['n', 'ん'], // 末尾の場合
]);

// 複数パターン対応例
const multiPatternKana: Map<string, string[]> = new Map([
  ['si', ['し', 'しぃ']],   // 'si' → 'し' または 'しぃ'
  ['ti', ['ち', 'ちぃ']],
  ['tu', ['つ', 'つぅ']],
  ['n', ['ん']],            // 通常は 'ん'
]);
```

#### 入力バッファと段階的マッチング
```typescript
class InputBuffer {
  private buffer: string = '';
  private matchedText: string = '';
  
  // 1文字ずつ追加してマッチ判定
  addChar(char: string): MatchResult {
    this.buffer += char;
    
    // 完全マッチを探す
    const match = this.findMatch(this.buffer);
    if (match && match.isComplete) {
      this.matchedText += match.kana;
      this.buffer = '';
      return { matched: true, kana: match.kana, remaining: '' };
    }
    
    // 部分マッチを確認（次の入力の可能性がある）
    const partial = this.isPartialMatch(this.buffer);
    if (partial) {
      return { matched: false, kana: '', remaining: this.buffer };
    }
    
    // マッチしない → エラー
    return { matched: false, error: true };
  }
  
  private findMatch(text: string): MatchInfo | null {
    return romajiMap.get(text) ? { kana: romajiMap.get(text)!, isComplete: true } : null;
  }
  
  private isPartialMatch(text: string): boolean {
    // テーブル内の任意のキーが text で始まるかチェック
    for (const key of romajiMap.keys()) {
      if (key.startsWith(text)) {
        return true;
      }
    }
    return false;
  }
}
```

**例：「きょう」の入力フロー**
```
1. 'k' → buffer='k', 部分マッチ(ka, ki, ku など存在) → 続行
2. 'y' → buffer='ky', 部分マッチ(kya, kyu など存在) → 続行
3. 'a' → buffer='kya', 完全マッチ → 'きゃ' に変換, buffer='', matchedText='きゃ'
4. 'u' → buffer='u', 完全マッチ → 'う' に変換, matchedText='きゃう' ❌
   本来は「きょう」だが「きゃう」と判定される
```

**改善案：バッファリングの仕組み**
```typescript
// ひらがなバッファで待機
class KanaConverter {
  private inputBuffer: string = '';
  
  convert(romaji: string): ConversionResult {
    this.inputBuffer += romaji;
    
    // 最長マッチを探す
    for (let i = this.inputBuffer.length; i > 0; i--) {
      const substr = this.inputBuffer.substring(0, i);
      if (romajiMap.has(substr)) {
        const kana = romajiMap.get(substr)!;
        this.inputBuffer = this.inputBuffer.substring(i);
        return { kana, remaining: this.inputBuffer };
      }
    }
    
    // マッチしないが部分マッチの可能性
    if (this.hasPartialMatch(this.inputBuffer)) {
      return { pending: true };
    }
    
    // エラー
    return { error: true };
  }
}
```

---

## 4. タイピング判定ロジック

### 4.1 判定フロー

```typescript
interface TypingState {
  targetText: string;        // 練習素材テキスト
  inputText: string;         // ユーザー入力テキスト
  currentIndex: number;      // 現在の入力位置
  errors: ErrorRecord[];     // 誤入力履歴
  startTime: number;         // 練習開始時刻
}

interface ErrorRecord {
  index: number;             // 誤入力位置
  expected: string;          // 期待される文字
  actual: string;            // 実際に入力された文字
  timestamp: number;
}

function judgeInput(
  event: HIDReport,
  state: TypingState,
  currentLayer: number
): JudgmentResult {
  // 1. キーコードを取得
  const keyCode = event.keyCodes[0];
  if (!keyCode) return { status: 'skip' };
  
  // 2. キーマップからキーコードを変換
  const char = convertKeyCodeToChar(keyCode, event.modifierByte, currentLayer);
  if (!char) return { status: 'skip' }; // 修飾キーなど
  
  // 3. 日本語入力の場合、バッファリング
  let inputChar = char;
  if (isJapaneseMode) {
    const convertResult = kanaConverter.convert(char);
    if (convertResult.pending) {
      return { status: 'pending', feedback: 'waiting_input' };
    }
    if (convertResult.error) {
      return { status: 'error', feedback: 'invalid_romaji' };
    }
    inputChar = convertResult.kana;
  }
  
  // 4. 期待される文字と比較
  const expectedChar = state.targetText[state.currentIndex];
  
  if (inputChar === expectedChar) {
    // 正解
    state.inputText += inputChar;
    state.currentIndex++;
    
    if (state.currentIndex >= state.targetText.length) {
      return { status: 'complete' };
    }
    return { status: 'success', feedback: 'correct' };
    
  } else {
    // 誤入力
    state.errors.push({
      index: state.currentIndex,
      expected: expectedChar,
      actual: inputChar,
      timestamp: Date.now(),
    });
    return { status: 'error', feedback: 'incorrect', expected: expectedChar, actual: inputChar };
  }
}
```

### 4.2 スキップ機能

**スキップは実装しない** - 誤入力を正すまで先に進めない

---

## 5. 統計情報の計算

### 5.1 WPM (Words Per Minute) の計算

```typescript
function calculateWPM(
  totalChars: number,
  totalTime: number // ミリ秒
): number {
  const minutes = totalTime / 1000 / 60;
  // 日本語の場合、1単語 = 1文字と考える
  const words = totalChars;
  return Math.round(words / minutes);
}
```

### 5.2 正確率の計算

```typescript
function calculateAccuracy(
  totalChars: number,
  errorCount: number
): number {
  const correctChars = totalChars - errorCount;
  const accuracy = (correctChars / totalChars) * 100;
  return Math.round(accuracy * 100) / 100; // 小数第2位まで
}
```

### 5.3 経過時間

```typescript
function getElapsedTime(startTime: number): string {
  const elapsed = Date.now() - startTime;
  const seconds = Math.floor(elapsed / 1000);
  const minutes = Math.floor(seconds / 60);
  const secs = seconds % 60;
  
  return `${minutes}:${String(secs).padStart(2, '0')}`;
}
```

### 5.4 リアルタイム統計の更新

```typescript
function updateStatistics(state: TypingState): Statistics {
  const elapsed = Date.now() - state.startTime;
  
  return {
    wpm: calculateWPM(state.inputText.length, elapsed),
    accuracy: calculateAccuracy(state.inputText.length, state.errors.length),
    errorCount: state.errors.length,
    elapsedTime: getElapsedTime(state.startTime),
    charCount: state.inputText.length,
  };
}
```

---

## 6. 誤入力フィードバック

### 6.1 ビジュアルフィードバック

```typescript
interface ErrorFeedback {
  type: 'visual' | 'audio';
  elements: {
    keyboard: {
      wrongKey: HIDKeyCode;
      highlightColor: '#FF6B6B'; // 赤色
      duration: 300; // ms
    },
    textInput: {
      backgroundColor: '#FFE0E0';
      duration: 300;
    },
    animation: 'shake'; // 画面揺らし
  };
}
```

### 6.2 フィードバック処理

```typescript
async function showErrorFeedback(error: JudgmentError) {
  // 1. キーボード表示上で該当キーを赤くハイライト
  highlightKey(error.keyCode, '#FF6B6B');
  
  // 2. 入力テキスト表示部分が点滅
  flashInputArea();
  
  // 3. 画面全体を軽く揺らす
  shakeScreen();
  
  // 4. 一定時間後にハイライト解除
  setTimeout(() => {
    removeKeyHighlight(error.keyCode);
  }, 300);
  
  // 5. オプション：ビープ音
  if (userSettings.soundEnabled) {
    playErrorSound();
  }
}
```

---

## 7. レイヤー管理と入力処理（将来実装）

### 7.1 MO(n) キー検知の課題

MO(n) キー押下の自動検知は、以下の理由により現バージョンでは未実装です：

1. **物理キー入力からの検知の困難性**: ブラウザのKeyboardEventでは、QMK/VIAレベルでのMO(n)キーの状態を直接取得できない
2. **キーマップへの依存**: MO(n)キーの位置はユーザーのキーマップ設定に依存するため、汎用的な検知が難しい
3. **代替手段の提供**: 手動レイヤー切り替えで同等の機能を実現

### 7.2 現在の実装: 手動レイヤー管理

```typescript
// useLayerManager composable による手動管理
const { toggleLayer, isLayerVisible, showOnlyLayer } = useLayerManager(0)

// ユーザーがUIから手動で切り替え
toggleLayer(1)  // レイヤー1の表示/非表示を切り替え
```

### 7.3 将来実装案: MO(n) キー自動検知

```typescript
// 将来実装例
const MO_KEY_CODE = 0x72; // 例（実際の値は設定に合わせる）

function handleKeyInput(event: HIDReport) {
  const keyCode = event.keyCodes[0];
  
  if (keyCode === MO_KEY_CODE) {
    // MO(n) キー押下 → レイヤー切り替え
    currentLayer = state.targetLayer;
    updateKeyboardDisplay(); // 新しいレイヤーを表示
    
  } else {
    // 通常のキー入力
    const char = convertKeyCodeToChar(keyCode, event.modifierByte, currentLayer);
    judgeInput(event, typingState, currentLayer);
  }
}

function handleKeyUp(event: HIDReport) {
  const keyCode = event.keyCodes[0];
  
  if (keyCode === MO_KEY_CODE) {
    // MO(n) キー解放 → レイヤー0に戻す
    currentLayer = 0;
    updateKeyboardDisplay();
  }
}
```

**注**: 上記は将来の実装案であり、現バージョンでは実装されていません。

---

## 8. エッジケースの処理

### 8.1 複数キー同時押し

日本語入力では通常、1キーずつの入力を想定しているが：

```typescript
// Shift + キーの場合（大文字など）
if (modifiers.shift) {
  // Shift適用後のキャラクターを取得
  const char = getCharWithShift(keyCode);
}

// Ctrl や Alt の場合（OSコマンド等）
if (modifiers.ctrl || modifiers.alt) {
  // スキップ（入力判定の対象外）
  return { status: 'skip' };
}
```

### 8.2 連続入力

バッファがある場合（ひらがな入力中）に次のキーが入力されるケース：

```typescript
// 例：'k' の次に 'a' が来た場合、'ka' → 'か'
// バッファ管理により自動的に処理
```

---

## 9. テスト戦略

### 9.1 単体テスト
- キーコード変換処理
- ひらがな変換ロジック
- WPM、正確率計算
- 判定ロジック

### 9.2 統合テスト
- 日本語入力の全フロー
- 誤入力時の処理フロー
- レイヤー表示管理とキーハイライト

### 9.3 シナリオテスト
```
シナリオ1: 「きょう」の入力
  k → y → a → u
  期待：『きょう』と表示
  
シナリオ2: 「にほんご」の入力
  n → i → h → o → n → g → o
  期待：『にほんご』と表示（複雑なローマ字組み合わせ）

シナリオ3: 誤入力「あ」を期待している状態で「い」を入力
  期待：赤色ハイライト + 画面揺らし
```
